"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SendSolTransactionRuleSchema = exports.SignSolTransactionRuleSchema = exports.SolOperationEnum = exports.SendSolTransactionCriteriaSchema = exports.SignSolTransactionCriteriaSchema = exports.MintAddressCriterionSchema = exports.SplValueCriterionSchema = exports.SplAddressCriterionSchema = exports.SolValueCriterionSchema = exports.SolAddressCriterionSchema = exports.MintAddressOperatorEnum = exports.SplValueOperatorEnum = exports.SplAddressOperatorEnum = exports.SolValueOperatorEnum = exports.SolAddressOperatorEnum = exports.ActionEnum = void 0;
const zod_1 = require("zod");
/**
 * Enum for Action types
 */
exports.ActionEnum = zod_1.z.enum(["reject", "accept"]);
/**
 * Enum for SolAddressOperator values
 */
exports.SolAddressOperatorEnum = zod_1.z.enum(["in", "not in"]);
/**
 * Enum for SolValueOperator values
 */
exports.SolValueOperatorEnum = zod_1.z.enum([">", ">=", "<", "<=", "=="]);
/**
 * Enum for SplAddressOperator values
 */
exports.SplAddressOperatorEnum = zod_1.z.enum(["in", "not in"]);
/**
 * Enum for SplValueOperator values
 */
exports.SplValueOperatorEnum = zod_1.z.enum([">", ">=", "<", "<=", "=="]);
/**
 * Enum for MintAddressOperator values
 */
exports.MintAddressOperatorEnum = zod_1.z.enum(["in", "not in"]);
/**
 * Schema for Solana address criterions
 */
exports.SolAddressCriterionSchema = zod_1.z.object({
    /** The type of criterion, must be "solAddress" for Solana address-based rules. */
    type: zod_1.z.literal("solAddress"),
    /**
     * Array of Solana addresses to compare against.
     * Each address must be a valid Base58-encoded Solana address (32-44 characters).
     */
    addresses: zod_1.z.array(zod_1.z.string().regex(/^[1-9A-HJ-NP-Za-km-z]{32,44}$/)),
    /**
     * The operator to use for evaluating transaction addresses.
     * "in" checks if an address is in the provided list.
     * "not in" checks if an address is not in the provided list.
     */
    operator: exports.SolAddressOperatorEnum,
});
/**
 * Schema for SOL value criterions
 */
exports.SolValueCriterionSchema = zod_1.z.object({
    /** The type of criterion, must be "solValue" for SOL value-based rules. */
    type: zod_1.z.literal("solValue"),
    /**
     * The SOL value amount in lamports to compare against, as a string.
     * Must contain only digits.
     */
    solValue: zod_1.z.string().regex(/^[0-9]+$/),
    /** The comparison operator to use for evaluating transaction SOL values against the threshold. */
    operator: exports.SolValueOperatorEnum,
});
/**
 * Schema for SPL address criterions
 */
exports.SplAddressCriterionSchema = zod_1.z.object({
    /** The type of criterion, must be "splAddress" for SPL address-based rules. */
    type: zod_1.z.literal("splAddress"),
    /**
     * Array of Solana addresses to compare against for SPL token transfer recipients.
     * Each address must be a valid Base58-encoded Solana address (32-44 characters).
     */
    addresses: zod_1.z.array(zod_1.z.string().regex(/^[1-9A-HJ-NP-Za-km-z]{32,44}$/)),
    /**
     * The operator to use for evaluating SPL token transfer recipient addresses.
     * "in" checks if an address is in the provided list.
     * "not in" checks if an address is not in the provided list.
     */
    operator: exports.SplAddressOperatorEnum,
});
/**
 * Schema for SPL value criterions
 */
exports.SplValueCriterionSchema = zod_1.z.object({
    /** The type of criterion, must be "splValue" for SPL token value-based rules. */
    type: zod_1.z.literal("splValue"),
    /**
     * The SPL token value amount to compare against, as a string.
     * Must contain only digits.
     */
    splValue: zod_1.z.string().regex(/^[0-9]+$/),
    /** The comparison operator to use for evaluating SPL token values against the threshold. */
    operator: exports.SplValueOperatorEnum,
});
/**
 * Schema for mint address criterions
 */
exports.MintAddressCriterionSchema = zod_1.z.object({
    /** The type of criterion, must be "mintAddress" for token mint address-based rules. */
    type: zod_1.z.literal("mintAddress"),
    /**
     * Array of Solana addresses to compare against for token mint addresses.
     * Each address must be a valid Base58-encoded Solana address (32-44 characters).
     */
    addresses: zod_1.z.array(zod_1.z.string().regex(/^[1-9A-HJ-NP-Za-km-z]{32,44}$/)),
    /**
     * The operator to use for evaluating token mint addresses.
     * "in" checks if an address is in the provided list.
     * "not in" checks if an address is not in the provided list.
     */
    operator: exports.MintAddressOperatorEnum,
});
/**
 * Schema for criteria used in SignSolTransaction operations
 */
exports.SignSolTransactionCriteriaSchema = zod_1.z
    .array(zod_1.z.discriminatedUnion("type", [
    exports.SolAddressCriterionSchema,
    exports.SolValueCriterionSchema,
    exports.SplAddressCriterionSchema,
    exports.SplValueCriterionSchema,
    exports.MintAddressCriterionSchema,
]))
    .max(10)
    .min(1);
/**
 * Schema for criteria used in SendSolTransaction operations
 */
exports.SendSolTransactionCriteriaSchema = zod_1.z
    .array(zod_1.z.discriminatedUnion("type", [
    exports.SolAddressCriterionSchema,
    exports.SolValueCriterionSchema,
    exports.SplAddressCriterionSchema,
    exports.SplValueCriterionSchema,
    exports.MintAddressCriterionSchema,
]))
    .max(10)
    .min(1);
/**
 * Enum for Solana Operation types
 */
exports.SolOperationEnum = zod_1.z.enum(["signSolTransaction", "sendSolTransaction"]);
/**
 * Type representing a 'signSolTransaction' policy rule that can accept or reject specific operations
 * based on a set of criteria.
 */
exports.SignSolTransactionRuleSchema = zod_1.z.object({
    /**
     * Determines whether matching the rule will cause a request to be rejected or accepted.
     * "accept" will allow the transaction, "reject" will block it.
     */
    action: exports.ActionEnum,
    /**
     * The operation to which this rule applies.
     * Must be "signSolTransaction".
     */
    operation: zod_1.z.literal("signSolTransaction"),
    /**
     * The set of criteria that must be matched for this rule to apply.
     * Must be compatible with the specified operation type.
     */
    criteria: exports.SignSolTransactionCriteriaSchema,
});
/**
 * Type representing a 'sendSolTransaction' policy rule that can accept or reject specific operations
 * based on a set of criteria.
 */
exports.SendSolTransactionRuleSchema = zod_1.z.object({
    /**
     * Determines whether matching the rule will cause a request to be rejected or accepted.
     * "accept" will allow the transaction, "reject" will block it.
     */
    action: exports.ActionEnum,
    /**
     * The operation to which this rule applies.
     * Must be "sendSolTransaction".
     */
    operation: zod_1.z.literal("sendSolTransaction"),
    /**
     * The set of criteria that must be matched for this rule to apply.
     * Must be compatible with the specified operation type.
     */
    criteria: exports.SendSolTransactionCriteriaSchema,
});
//# sourceMappingURL=solanaSchema.js.map