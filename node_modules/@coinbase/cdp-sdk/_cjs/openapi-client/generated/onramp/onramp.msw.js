"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOnrampMock = exports.getGetOnrampOrderByIdMockHandler = exports.getCreateOnrampOrderMockHandler = exports.getGetOnrampOrderByIdResponseMock = exports.getCreateOnrampOrderResponseMock = void 0;
/**
 * Generated by orval v7.6.0 🍺
 * Do not edit manually.
 * Coinbase Developer Platform APIs
 * The Coinbase Developer Platform APIs - leading the world's transition onchain.
 * OpenAPI spec version: 2.0.0
 */
const faker_1 = require("@faker-js/faker");
const msw_1 = require("msw");
const coinbaseDeveloperPlatformAPIs_schemas_js_1 = require("../coinbaseDeveloperPlatformAPIs.schemas.js");
const getCreateOnrampOrderResponseMock = (overrideResponse = {}) => ({
    order: {
        orderId: faker_1.faker.string.alpha(20),
        paymentTotal: faker_1.faker.string.alpha(20),
        paymentSubtotal: faker_1.faker.string.alpha(20),
        paymentCurrency: faker_1.faker.string.alpha(20),
        paymentMethod: faker_1.faker.helpers.arrayElement(Object.values(coinbaseDeveloperPlatformAPIs_schemas_js_1.OnrampPaymentMethodTypeId)),
        purchaseAmount: faker_1.faker.string.alpha(20),
        purchaseCurrency: faker_1.faker.string.alpha(20),
        fees: Array.from({ length: faker_1.faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
            type: faker_1.faker.helpers.arrayElement(["FEE_TYPE_NETWORK", "FEE_TYPE_EXCHANGE"]),
            amount: faker_1.faker.string.alpha(20),
            currency: faker_1.faker.string.alpha(20),
        })),
        exchangeRate: faker_1.faker.string.alpha(20),
        destinationAddress: faker_1.faker.string.alpha(20),
        destinationNetwork: faker_1.faker.string.alpha(20),
        status: faker_1.faker.helpers.arrayElement(Object.values(coinbaseDeveloperPlatformAPIs_schemas_js_1.OnrampOrderStatus)),
        txHash: faker_1.faker.helpers.arrayElement([faker_1.faker.string.alpha(20), undefined]),
        createdAt: faker_1.faker.string.alpha(20),
        updatedAt: faker_1.faker.string.alpha(20),
    },
    paymentLink: faker_1.faker.helpers.arrayElement([
        {
            url: faker_1.faker.string.alpha(20),
            paymentLinkType: faker_1.faker.helpers.arrayElement(Object.values(coinbaseDeveloperPlatformAPIs_schemas_js_1.OnrampPaymentLinkType)),
        },
        undefined,
    ]),
    ...overrideResponse,
});
exports.getCreateOnrampOrderResponseMock = getCreateOnrampOrderResponseMock;
const getGetOnrampOrderByIdResponseMock = (overrideResponse = {}) => ({
    order: {
        orderId: faker_1.faker.string.alpha(20),
        paymentTotal: faker_1.faker.string.alpha(20),
        paymentSubtotal: faker_1.faker.string.alpha(20),
        paymentCurrency: faker_1.faker.string.alpha(20),
        paymentMethod: faker_1.faker.helpers.arrayElement(Object.values(coinbaseDeveloperPlatformAPIs_schemas_js_1.OnrampPaymentMethodTypeId)),
        purchaseAmount: faker_1.faker.string.alpha(20),
        purchaseCurrency: faker_1.faker.string.alpha(20),
        fees: Array.from({ length: faker_1.faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
            type: faker_1.faker.helpers.arrayElement(["FEE_TYPE_NETWORK", "FEE_TYPE_EXCHANGE"]),
            amount: faker_1.faker.string.alpha(20),
            currency: faker_1.faker.string.alpha(20),
        })),
        exchangeRate: faker_1.faker.string.alpha(20),
        destinationAddress: faker_1.faker.string.alpha(20),
        destinationNetwork: faker_1.faker.string.alpha(20),
        status: faker_1.faker.helpers.arrayElement(Object.values(coinbaseDeveloperPlatformAPIs_schemas_js_1.OnrampOrderStatus)),
        txHash: faker_1.faker.helpers.arrayElement([faker_1.faker.string.alpha(20), undefined]),
        createdAt: faker_1.faker.string.alpha(20),
        updatedAt: faker_1.faker.string.alpha(20),
    },
    ...overrideResponse,
});
exports.getGetOnrampOrderByIdResponseMock = getGetOnrampOrderByIdResponseMock;
const getCreateOnrampOrderMockHandler = (overrideResponse) => {
    return msw_1.http.post("*/v2/onramp/orders", async (info) => {
        await (0, msw_1.delay)(0);
        return new msw_1.HttpResponse(JSON.stringify(overrideResponse !== undefined
            ? typeof overrideResponse === "function"
                ? await overrideResponse(info)
                : overrideResponse
            : (0, exports.getCreateOnrampOrderResponseMock)()), { status: 201, headers: { "Content-Type": "application/json" } });
    });
};
exports.getCreateOnrampOrderMockHandler = getCreateOnrampOrderMockHandler;
const getGetOnrampOrderByIdMockHandler = (overrideResponse) => {
    return msw_1.http.get("*/v2/onramp/orders/:orderId", async (info) => {
        await (0, msw_1.delay)(0);
        return new msw_1.HttpResponse(JSON.stringify(overrideResponse !== undefined
            ? typeof overrideResponse === "function"
                ? await overrideResponse(info)
                : overrideResponse
            : (0, exports.getGetOnrampOrderByIdResponseMock)()), { status: 200, headers: { "Content-Type": "application/json" } });
    });
};
exports.getGetOnrampOrderByIdMockHandler = getGetOnrampOrderByIdMockHandler;
const getOnrampMock = () => [
    (0, exports.getCreateOnrampOrderMockHandler)(),
    (0, exports.getGetOnrampOrderByIdMockHandler)(),
];
exports.getOnrampMock = getOnrampMock;
//# sourceMappingURL=onramp.msw.js.map